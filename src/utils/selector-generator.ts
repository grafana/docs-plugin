/**
 * Smart selector generation for DOM elements
 * Creates robust, human-readable selectors while avoiding auto-generated classes
 *
 * This utility is generic and can be used in any context where you need to
 * programmatically generate CSS selectors for DOM elements.
 *
 * Key features:
 * - Walks up DOM hierarchy to find best selectable parent
 * - Prioritizes stable attributes (data-testid, id, aria-label)
 * - Filters out auto-generated classes (Emotion, CSS modules, etc.)
 * - Handles nested elements (clicks on icons/spans find parent button/link)
 * - Context-aware (includes parent selectors when needed)
 *
 * @module selector-generator
 */

import { findButtonByText } from './dom-utils';
import { querySelectorAllEnhanced } from './enhanced-selector';

/**
 * Check if an ID appears to be auto-generated
 */
function isAutoGeneratedId(id: string): boolean {
  // IDs with random hashes or UUIDs
  if (id.length > 20) {
    return true;
  }
  if (/^[a-f0-9]{8,}/.test(id)) {
    return true;
  } // Hex hashes
  if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {
    return true;
  } // UUID
  if (/^id-\d+/.test(id)) {
    return true;
  } // Auto-incremented IDs
  if (/^react-/.test(id)) {
    return true;
  } // React-generated IDs

  return false;
}

/**
 * Patterns for stable, semantic CSS classes that should be kept
 */
const STABLE_CLASS_PATTERNS = [
  /^[a-z][a-z0-9-]*(__[a-z0-9-]+)?(--[a-z0-9-]+)?$/, // BEM: block__element--modifier
  /^[a-z][a-z0-9-]+$/, // Simple kebab-case (min 2 chars to avoid 'p', 'm', etc.)
];

/**
 * Check if a class matches stable naming patterns
 */
function isStableClass(className: string): boolean {
  return STABLE_CLASS_PATTERNS.some((pattern) => pattern.test(className));
}

/**
 * Check if a class appears to be auto-generated or utility-only
 */
function isAutoGeneratedClass(className: string): boolean {
  // First check if it matches stable patterns (whitelist)
  if (isStableClass(className)) {
    return false;
  }

  // Emotion/styled-components classes
  if (className.startsWith('css-')) {
    return true;
  }

  // Classes with long hash patterns (8+ alphanumeric)
  if (/[a-zA-Z0-9]{8,}/.test(className)) {
    return true;
  }

  // Common utility classes that don't help identify elements
  const utilityClasses = [
    'flex',
    'flex-row',
    'flex-col',
    'block',
    'inline',
    'hidden',
    'absolute',
    'relative',
    'fixed',
    'static',
    'w-full',
    'h-full',
    'p-0',
    'p-1',
    'p-2',
    'p-3',
    'p-4',
    'm-0',
    'm-1',
    'm-2',
    'm-3',
    'm-4',
    'text-left',
    'text-center',
    'text-right',
    'font-bold',
    'font-normal',
    'font-light',
  ];

  if (utilityClasses.includes(className)) {
    return true;
  }

  // Grafana-specific utility patterns
  if (className.match(/^(theme|color|bg|border|rounded|shadow)-/)) {
    return true;
  }

  return false;
}

/**
 * Get unique, meaningful classes from an element
 */
function getMeaningfulClasses(element: HTMLElement): string[] {
  if (!element.className) {
    return [];
  }

  const classes = element.className.split(/\s+/).filter(Boolean);
  return classes.filter((cls) => !isAutoGeneratedClass(cls));
}

/**
 * Normalize text by removing RTL/LTR marks and collapsing whitespace
 */
function normalizeText(text: string): string {
  return text
    .replace(/[\u200e\u200f]/g, '') // Remove RTL/LTR marks
    .replace(/\s+/g, ' ') // Collapse whitespace
    .trim();
}

/**
 * Normalize href by removing query strings and hashes while preserving relative/absolute path
 * Keeps the original path format (relative vs absolute) for exact attribute matching
 */
function normalizeHref(href: string): string {
  try {
    // For URLs with query strings or hashes, strip them
    const hashIndex = href.indexOf('#');
    const queryIndex = href.indexOf('?');
    
    let endIndex = href.length;
    if (hashIndex > 0) {
      endIndex = hashIndex;
    }
    if (queryIndex > 0 && queryIndex < endIndex) {
      endIndex = queryIndex;
    }
    
    // Return the path portion, preserving relative vs absolute format
    return href.substring(0, endIndex);
  } catch {
    return href; // Invalid URL, return as-is
  }
}

/**
 * Get test ID from any supported test ID attribute
 * Supports multiple conventions: data-testid, data-cy, data-test-id, data-qa, data-test-subj
 */
function getAnyTestId(element: HTMLElement): string | null {
  const testIdAttrs = ['data-testid', 'data-cy', 'data-test-id', 'data-qa', 'data-test-subj'];

  for (const attr of testIdAttrs) {
    if (element.hasAttribute(attr)) {
      return element.getAttribute(attr);
    }
  }

  return null;
}

/**
 * Check if button text is unique enough to use as a selector
 * Also filters out overly generic words that shouldn't be used alone
 */
function isUniqueButtonText(text: string): boolean {
  if (!text || text.length < 2) {
    return false;
  }

  // Too short or too generic - always need more context
  const genericWords = [
    'new',
    'add',
    'save',
    'cancel',
    'close',
    'ok',
    'yes',
    'no',
    'edit',
    'delete',
    'remove',
    'update',
    'submit',
    'back',
    'next',
    'confirm',
    'apply',
    'reset',
    'clear',
    'search',
    'filter',
  ];

  if (text.length < 4 || genericWords.includes(text.toLowerCase())) {
    return false; // Always need parent context for these
  }

  // Use findButtonByText to check uniqueness
  const buttons = findButtonByText(text);
  return buttons.length === 1;
}

// Note: buildCompoundSelector was replaced by buildCompoundSelectorWithContext
// which provides better specificity by including parent context

/**
 * Check if an element is a card-like container
 * Cards are common UI patterns where the entire container is clickable
 */
function isCardLikeContainer(element: HTMLElement): boolean {
  const classNames = element.className.toString().toLowerCase();
  
  // Common card patterns in class names
  if (classNames.includes('card')) {
    return true;
  }
  
  // List items with clickable content patterns
  if (element.tagName.toLowerCase() === 'li') {
    // Check if it has card-like structure (multiple child sections)
    const childDivs = element.querySelectorAll(':scope > div, :scope > div > div');
    if (childDivs.length >= 2) {
      return true;
    }
  }
  
  // Divs with specific roles that indicate containers
  const role = element.getAttribute('role');
  if (role && ['article', 'group', 'listitem', 'option'].includes(role)) {
    return true;
  }
  
  return false;
}

/**
 * Find the best element in the hierarchy (walk up to find semantic attributes)
 * Often users click on a span/icon inside a button/link - we want the parent
 * Prioritizes elements with strong selectable attributes
 * Detects card-like patterns to avoid over-prioritizing buttons inside cards
 */
function findBestElementInHierarchy(element: HTMLElement, maxDepth = 5): HTMLElement {
  let current: HTMLElement | null = element;
  let depth = 0;
  let bestElement = element;
  let bestScore = scoreElement(element);

  // Track if we're inside a card-like container
  let cardBoundary: HTMLElement | null = null;

  // First pass: Check for card boundaries in the entire hierarchy first
  // This prevents us from selecting buttons inside cards
  let searchElement: HTMLElement | null = element;
  let searchDepth = 0;
  while (searchElement && searchDepth < maxDepth) {
    if (isCardLikeContainer(searchElement)) {
      cardBoundary = searchElement;
      break; // Found a card, stop looking for more
    }
    searchElement = searchElement.parentElement;
    searchDepth++;
  }

  // Second pass: look for elements with any test ID (highest priority!)
  // Also look for interactive elements, respecting card boundaries
  searchElement = element;
  searchDepth = 0;
  while (searchElement && searchDepth < maxDepth) {
    const tag = searchElement.tagName.toLowerCase();

    // If we find any test ID attribute, that's almost always perfect!
    if (getAnyTestId(searchElement)) {
      return searchElement;
    }

    // If we're inside a card and at a button/link, return the card instead
    if (cardBoundary && (tag === 'button' || tag === 'a')) {
      // The contextual selector builder will make it unique using :has() with the button content
      return cardBoundary;
    }

    // For elements NOT inside cards, links/buttons are excellent targets
    if (!cardBoundary) {
    if (tag === 'a' || tag === 'button' || tag === 'input' || tag === 'textarea' || tag === 'select') {
      return searchElement;
      }
    }

    // If we find aria-label on an interactive element (div with role, etc.)
    if (searchElement.hasAttribute('aria-label')) {
      const role = searchElement.getAttribute('role');
      // Check if it's an interactive element (button, option, menuitem, combobox, etc.)
      if (role && ['button', 'menuitem', 'option', 'radio', 'checkbox', 'tab', 'combobox', 'listbox'].includes(role)) {
        return searchElement;
      }
      // For visualization pickers and similar, aria-label on div is often the target
      if (getAnyTestId(searchElement)) {
        return searchElement;
      }
    }

    searchElement = searchElement.parentElement;
    searchDepth++;
  }

  // Second pass: score-based search if no priority element found
  current = element;
  depth = 0;
  while (current && depth < maxDepth) {
    const score = scoreElement(current);

    if (score > bestScore) {
      bestScore = score;
      bestElement = current;
    }

    current = current.parentElement;
    depth++;
  }

  return bestElement;
}

/**
 * Score an element based on how good its attributes are for selection
 */
function scoreElement(element: HTMLElement): number {
  let score = 0;

  // Highest priority: data-testid
  if (element.hasAttribute('data-testid')) {
    score += 100;
  }

  // High priority: non-auto-generated ID
  if (element.id && !isAutoGeneratedId(element.id)) {
    score += 80;
  }

  // Good priority: aria-label
  if (element.hasAttribute('aria-label')) {
    score += 70;
  }

  // Medium priority: name attribute for inputs
  if (element.hasAttribute('name')) {
    score += 60;
  }

  // Medium priority: href for links (bump this up - links are important!)
  if (element.hasAttribute('href')) {
    score += 55;
  }

  // Very high bonus for links and buttons (they're the actual clickable elements)
  const tag = element.tagName.toLowerCase();
  if (tag === 'a') {
    score += 40;
  } // Links are very important for navigation
  if (tag === 'button') {
    score += 35;
  }

  // Bonus for other semantic tags
  const semanticTags = ['input', 'select', 'textarea'];
  if (semanticTags.includes(tag)) {
    score += 20;
  }

  // Heavy penalty for generic tags (we want to walk up past these)
  if (tag === 'SPAN') {
    score -= 20;
  }
  if (tag === 'DIV') {
    score -= 15;
  }
  if (tag === 'SVG' || tag === 'PATH') {
    score -= 25;
  } // Icons should find their parent

  return score;
}

/**
 * Generate the best CSS selector for a given DOM element
 *
 * This is the main entry point for selector generation. It automatically:
 * - Walks up the DOM tree to find the most semantically meaningful parent
 * - Prioritizes stable attributes over fragile ones
 * - Handles edge cases like clicking icons inside buttons/links
 * - Returns production-ready selectors suitable for test automation
 *
 * Priority order:
 * 1. data-testid attribute (most stable for testing)
 * 2. Non-auto-generated ID
 * 3. aria-label (semantic and accessible)
 * 4. name attribute (for form inputs)
 * 5. href attribute (for links)
 * 6. Unique button text (using findButtonByText)
 * 7. Compound selector with parent context
 * 8. Fallback to :nth-of-type
 *
 * @param element - Any HTMLElement from the DOM
 * @returns A CSS selector string that can be used with querySelector/querySelectorAll
 *
 * @example
 * ```typescript
 * // Clicking a span inside a navigation link
 * const span = document.querySelector('a[href="/dashboards"] > span');
 * const selector = generateBestSelector(span);
 * // Returns: "a[data-testid='Nav menu item'][href='/dashboards']"
 *
 * // Clicking a button with unique text
 * const button = document.querySelector('button');
 * const selector = generateBestSelector(button);
 * // Returns: "Save Dashboard" (uses button text matching)
 * ```
 */
export function generateBestSelector(element: HTMLElement): string {
  // First, walk up to find the best element in the hierarchy
  const bestElement = findBestElementInHierarchy(element);

  // 1. Check any test ID attribute (most stable)
  const testId = getAnyTestId(bestElement);
  if (testId) {
    const tag = bestElement.tagName.toLowerCase();
    // Determine which attribute was used
    const testIdAttr =
      ['data-testid', 'data-cy', 'data-test-id', 'data-qa', 'data-test-subj'].find((attr) =>
        bestElement.hasAttribute(attr)
      ) || 'data-testid';

    // For links, include normalized href for specificity
    if (tag === 'a' && bestElement.hasAttribute('href')) {
      const href = normalizeHref(bestElement.getAttribute('href')!);
      const baseSelector = `${tag}[${testIdAttr}="${testId}"][href="${href}"]`;
      return buildContextualSelector(bestElement, baseSelector);
    }

    const baseSelector = `${tag}[${testIdAttr}="${testId}"]`;
    return buildContextualSelector(bestElement, baseSelector);
  }

  // 2. Check ID (if not auto-generated)
  if (bestElement.id && !isAutoGeneratedId(bestElement.id)) {
    const baseSelector = `#${bestElement.id}`;
    return buildContextualSelector(bestElement, baseSelector);
  }

  // 3. For buttons, prioritize visible text over aria-label (users interact with what they see)
  if (bestElement.tagName === 'BUTTON') {
    const text = bestElement.textContent;
    if (text && text.length > 0) {
      const cleanText = normalizeText(text);

      if (cleanText.length > 0 && cleanText.length < 50) {
        // Strategy A: Parent context + :contains (preferred for most buttons)
        const parent = bestElement.parentElement;
        if (parent && (getAnyTestId(parent) || parent.id || parent.hasAttribute('aria-label'))) {
          const parentSelector = generateBestSelector(parent);
          return `${parentSelector} button:contains("${cleanText}")`;
        }

        // Strategy B: Standalone text ONLY if unique AND not generic
        if (isUniqueButtonText(cleanText)) {
          return cleanText; // Will use findButtonByText
        }

        // Strategy C: Standalone :contains as fallback (with validation)
        const baseSelector = `button:contains("${cleanText}")`;
        return buildContextualSelector(bestElement, baseSelector);
      }
    }
  }

  // 4. Check aria-label (semantic and stable) - but after button text
  if (bestElement.hasAttribute('aria-label')) {
    const ariaLabel = bestElement.getAttribute('aria-label');
    const tag = bestElement.tagName.toLowerCase();
    const baseSelector = `${tag}[aria-label="${ariaLabel}"]`;
    return buildContextualSelector(bestElement, baseSelector);
  }

  // 5. For inputs, check name attribute
  if (
    (bestElement.tagName === 'INPUT' || bestElement.tagName === 'TEXTAREA' || bestElement.tagName === 'SELECT') &&
    bestElement.hasAttribute('name')
  ) {
    const name = bestElement.getAttribute('name');
    const tag = bestElement.tagName.toLowerCase();
    const baseSelector = `${tag}[name="${name}"]`;
    return buildContextualSelector(bestElement, baseSelector);
  }

  // 6. For links with href, use normalized pathname
  if (bestElement.tagName === 'A' && bestElement.hasAttribute('href')) {
    const href = normalizeHref(bestElement.getAttribute('href')!);
    const baseSelector = `a[href="${href}"]`;
    return buildContextualSelector(bestElement, baseSelector);
  }

  // 7. Build compound selector with tag + attributes + parent context
  const compoundSelector = buildCompoundSelectorWithContext(bestElement);
  return buildContextualSelector(bestElement, compoundSelector);
}

/**
 * Get all descendants up to a specified depth using BFS traversal
 * @param element - Root element to start from
 * @param maxDepth - Maximum depth to traverse (1 = direct children, 2 = children + grandchildren)
 * @returns Array of descendant elements up to maxDepth
 */
function getDescendantsUpToDepth(element: HTMLElement, maxDepth: number): HTMLElement[] {
  const descendants: HTMLElement[] = [];
  const queue: Array<{ element: HTMLElement; depth: number }> = [{ element, depth: 0 }];

  while (queue.length > 0) {
    const { element: current, depth } = queue.shift()!;

    if (depth >= maxDepth) {
      continue;
    }

    // Add children to queue and to results
    Array.from(current.children).forEach((child) => {
      if (child instanceof HTMLElement) {
        descendants.push(child);
        queue.push({ element: child, depth: depth + 1 });
      }
    });
  }

  return descendants;
}

/**
 * Check if an element is a leaf text element (no semantic children, just text)
 * Used to determine if we should use the element's text content for matching
 */
function isLeafTextElement(element: HTMLElement): boolean {
  const tag = element.tagName.toLowerCase();
  
  // These are always leaf elements
  if (['button', 'a', 'span', 'label', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p'].includes(tag)) {
    return true;
  }
  
  // For other elements (div, li, etc.), check if they have semantic children
  // If they have semantic children, they're containers, not leaf elements
  const semanticChildren = element.querySelectorAll('button, a, h1, h2, h3, h4, h5, h6, input, select, textarea');
  
  return semanticChildren.length === 0;
}

/**
 * Extract a unique identifier from a child element for use in :has() selector
 * Returns selector fragment or null if child has no useful identifiers
 * Prioritizes specific semantic elements over container divs with all text
 */
function getUniqueChildIdentifier(child: HTMLElement): string | null {
  const tag = child.tagName.toLowerCase();

  // Priority 1: Test ID attribute
  const testId = getAnyTestId(child);
  if (testId) {
    const testIdAttr =
      ['data-testid', 'data-cy', 'data-test-id', 'data-qa', 'data-test-subj'].find((attr) =>
        child.hasAttribute(attr)
      ) || 'data-testid';
    return `${tag}[${testIdAttr}="${testId}"]`;
  }

  // Priority 2: Non-auto-generated ID
  if (child.id && !isAutoGeneratedId(child.id)) {
    return `#${child.id}`;
  }

  // Priority 3: Text content (ONLY for leaf elements to avoid container divs with all nested text)
  const textContent = normalizeText(child.textContent || '');
  if (textContent.length > 0 && textContent.length < 50 && isLeafTextElement(child)) {
    return `${tag}:contains("${textContent}")`;
  }

  // Priority 4: aria-label (after text content)
  if (child.hasAttribute('aria-label')) {
    const ariaLabel = child.getAttribute('aria-label');
    return `${tag}[aria-label="${ariaLabel}"]`;
  }

  // Priority 5: Meaningful classes
  const meaningfulClasses = getMeaningfulClasses(child);
  if (meaningfulClasses.length > 0) {
    return `${tag}.${meaningfulClasses[0]}`;
  }

  return null;
}

/**
 * Find unique child context by examining descendants
 * Builds :has() selectors based on distinguishing child elements
 */
function findUniqueChildContext(
  element: HTMLElement,
  baseSelector: string,
  allMatches: HTMLElement[]
): string | null {
  // Get descendants up to 2 levels deep
  const descendants = getDescendantsUpToDepth(element, 2);

  // Try single child distinguishers first
  for (const child of descendants) {
    const childIdentifier = getUniqueChildIdentifier(child);
    if (!childIdentifier) {
      continue;
    }

    const candidateSelector = `${baseSelector}:has(${childIdentifier})`;
    try {
      const result = querySelectorAllEnhanced(candidateSelector);

      // Check if this makes the selector unique and still matches our element
      if (result.elements.length === 1 && result.elements[0] === element) {
        return candidateSelector;
      }
    } catch (error) {
      // Selector validation failed, try next child
      continue;
    }
  }

  // Try combining two children for more specificity
  for (let i = 0; i < descendants.length && i < 5; i++) {
    const firstChild = descendants[i];
    const firstIdentifier = getUniqueChildIdentifier(firstChild);
    if (!firstIdentifier) {
      continue;
    }

    for (let j = i + 1; j < descendants.length && j < 5; j++) {
      const secondChild = descendants[j];
      const secondIdentifier = getUniqueChildIdentifier(secondChild);
      if (!secondIdentifier) {
        continue;
      }

      const candidateSelector = `${baseSelector}:has(${firstIdentifier}):has(${secondIdentifier})`;
      try {
        const result = querySelectorAllEnhanced(candidateSelector);

        if (result.elements.length === 1 && result.elements[0] === element) {
          return candidateSelector;
        }
      } catch (error) {
        continue;
      }
    }
  }

  return null;
}

/**
 * Find unique parent context by traversing up the hierarchy
 * Combines parent selector with current element selector
 */
function findUniqueParentContext(element: HTMLElement, baseSelector: string): string | null {
  let currentParent = element.parentElement;
  let depth = 0;
  const maxDepth = 2;

  while (currentParent && depth < maxDepth) {
    // Avoid infinite recursion by checking if parent has better attributes than child
    const parentTestId = getAnyTestId(currentParent);
    const parentId = currentParent.id && !isAutoGeneratedId(currentParent.id);
    const parentAriaLabel = currentParent.hasAttribute('aria-label');

    if (parentTestId || parentId || parentAriaLabel) {
      try {
        // Generate parent selector (but prevent it from recursively adding context)
        const parentSelector = generateBestSelectorWithoutContext(currentParent);
        const candidateSelector = `${parentSelector} ${baseSelector}`;

        const result = querySelectorAllEnhanced(candidateSelector);

        // Check if this makes the selector unique
        if (result.elements.length === 1 && result.elements[0] === element) {
          return candidateSelector;
        }
      } catch (error) {
        // Parent selector failed, try next level
      }
    }

    currentParent = currentParent.parentElement;
    depth++;
  }

  return null;
}

/**
 * Add :nth-match() context as last resort for positional selection
 * Finds element's position among all matches
 */
function addNthMatchContext(element: HTMLElement, baseSelector: string, allMatches: HTMLElement[]): string {
  const index = allMatches.indexOf(element);
  if (index >= 0) {
    return `${baseSelector}:nth-match(${index + 1})`;
  }
  // If element not found in matches (shouldn't happen), return base selector
  return baseSelector;
}

/**
 * Build contextual selector with validation and hierarchical context
 * Orchestrates child, parent, and positional context strategies
 */
function buildContextualSelector(element: HTMLElement, baseSelector: string): string {
  // First, validate if base selector is already unique
  try {
    const matches = querySelectorAllEnhanced(baseSelector);

    if (matches.elements.length === 1) {
      // Already unique, no context needed
      return baseSelector;
    }

    if (matches.elements.length === 0) {
      // Selector doesn't match anything, return as-is (might be invalid)
      return baseSelector;
    }

    // Strategy 1: Try child distinguishers using :has()
    const childContext = findUniqueChildContext(element, baseSelector, matches.elements);
    if (childContext) {
      return childContext;
    }

    // Strategy 2: Try parent context
    const parentContext = findUniqueParentContext(element, baseSelector);
    if (parentContext) {
      return parentContext;
    }

    // Strategy 3: Use :nth-match() as last resort
    return addNthMatchContext(element, baseSelector, matches.elements);
  } catch (error) {
    // If validation fails, return base selector
    console.warn(`Context validation failed for "${baseSelector}":`, error);
    return baseSelector;
  }
}

/**
 * Generate selector without contextual validation (used internally to prevent recursion)
 * This is the original selector generation logic without the validation layer
 */
function generateBestSelectorWithoutContext(element: HTMLElement): string {
  // Use basic selector generation without recursive context building
  const bestElement = findBestElementInHierarchy(element);
  const tag = bestElement.tagName.toLowerCase();

  // Priority 1: Test ID
  const testId = getAnyTestId(bestElement);
  if (testId) {
    const testIdAttr =
      ['data-testid', 'data-cy', 'data-test-id', 'data-qa', 'data-test-subj'].find((attr) =>
        bestElement.hasAttribute(attr)
      ) || 'data-testid';
    return `${tag}[${testIdAttr}="${testId}"]`;
  }

  // Priority 2: Non-auto-generated ID
  if (bestElement.id && !isAutoGeneratedId(bestElement.id)) {
    return `#${bestElement.id}`;
  }

  // Priority 3: aria-label
  if (bestElement.hasAttribute('aria-label')) {
    const ariaLabel = bestElement.getAttribute('aria-label');
    return `${tag}[aria-label="${ariaLabel}"]`;
  }

  // Fallback to tag
  return tag;
}

/**
 * Build compound selector with parent context for better specificity
 * Uses parent selectors and :contains() when appropriate
 */
function buildCompoundSelectorWithContext(element: HTMLElement): string {
  const tag = element.tagName.toLowerCase();
  const parts: string[] = [tag];

  // Add meaningful classes
  const meaningfulClasses = getMeaningfulClasses(element);
  if (meaningfulClasses.length > 0) {
    parts.push(`.${meaningfulClasses[0]}`);
  }

  // Add data attributes (except auto-generated ones)
  Array.from(element.attributes).forEach((attr) => {
    if (
      attr.name.startsWith('data-') &&
      !attr.name.includes('emotion') &&
      !attr.name.includes('react') &&
      attr.value.length < 50
    ) {
      parts.push(`[${attr.name}="${attr.value}"]`);
    }
  });

  // Add normalized href for links
  if (tag === 'a' && element.hasAttribute('href')) {
    const href = normalizeHref(element.getAttribute('href')!);
    parts.push(`[href="${href}"]`);
  }

  // If we still don't have enough specificity, try these strategies:

  // Strategy 1: Use parent context if parent has good identifiers
  if (parts.length <= 2 && element.parentElement) {
    const parent = element.parentElement;

    // Check if parent has good identifying attributes
    if (getAnyTestId(parent) || parent.id || parent.hasAttribute('aria-label')) {
      const parentSelector = generateBestSelector(parent);

      // For buttons with text, use :contains for better readability
      if (tag === 'button' && element.textContent) {
        const text = normalizeText(element.textContent);
        if (text.length > 0 && text.length < 50) {
          return `${parentSelector} button:contains("${text}")`;
        }
      }

      return `${parentSelector} ${parts.join('')}`;
    }
  }

  // Strategy 2: Use :contains as fallback for LEAF elements only (buttons/links with short text)
  if ((tag === 'button' || tag === 'a') && element.textContent) {
    const text = normalizeText(element.textContent);
    if (text.length > 0 && text.length < 50) {
      return `${tag}:contains("${text}")`;
    }
  }

  // Strategy 3 removed - let buildContextualSelector handle text-based context via :has()
  // This prevents container divs from using their full nested text content

  // Strategy 4: Add :nth-of-type with parent context as last resort
  if (element.parentElement) {
    const siblings = Array.from(element.parentElement.children).filter((el) => el.tagName === element.tagName);
    const index = siblings.indexOf(element) + 1;
    if (index > 0) {
      parts.push(`:nth-of-type(${index})`);

      // Try to add parent context for better specificity
      const parent = element.parentElement;
      if (getAnyTestId(parent) || parent.id || parent.hasAttribute('aria-label')) {
        const parentSelector = generateBestSelector(parent);
        return `${parentSelector} > ${parts.join('')}`;
      }
    }
  }

  // Absolute last resort: just return what we have
  return parts.length > 0 ? parts.join('') : `${tag}`;
}

/**
 * Get information about the generated selector for debugging
 * Returns the selector along with metadata about how it was generated
 *
 * @param element - The DOM element to analyze
 * @returns Object containing selector, generation method, uniqueness, match count, and context strategy
 *
 * @example
 * ```typescript
 * const info = getSelectorInfo(myElement);
 * console.log(info.selector); // "button[data-testid='save']"
 * console.log(info.method);   // "data-testid"
 * console.log(info.isUnique); // true
 * console.log(info.contextStrategy); // "child-has"
 * ```
 */
export function getSelectorInfo(element: HTMLElement): {
  selector: string;
  method: string;
  isUnique: boolean;
  matchCount: number;
  contextStrategy?: string;
} {
  const selector = generateBestSelector(element);

  // Determine which method was used
  let method = 'compound';
  if (selector.includes('data-testid') || selector.includes('data-cy') || selector.includes('data-test-id')) {
    method = 'data-testid';
  } else if (selector.startsWith('#')) {
    method = 'id';
  } else if (selector.includes('aria-label')) {
    method = 'aria-label';
  } else if (selector.includes('[name=')) {
    method = 'name';
  } else if (selector.includes('[href=')) {
    method = 'href';
  } else if (!selector.includes('[') && !selector.includes('.') && !selector.includes('#') && !selector.includes(':')) {
    method = 'button-text';
  } else if (selector.includes(':nth-of-type')) {
    method = 'nth-of-type';
  } else if (selector.includes(':contains(')) {
    method = 'contains';
  }

  // Determine context strategy used
  let contextStrategy: string | undefined;
  if (selector.includes(':has(')) {
    contextStrategy = 'child-has';
  } else if (selector.includes(':nth-match(')) {
    contextStrategy = 'nth-match';
  } else if (selector.includes(' ') && !selector.includes(':contains(')) {
    // Has descendant combinator (space) but not just :contains
    contextStrategy = 'parent-context';
  }

  // Check uniqueness using enhanced selector for :contains() and :has() support
  let matchCount = 0;
  try {
    if (method === 'button-text') {
      matchCount = findButtonByText(selector).length;
    } else if (method === 'contains' || selector.includes(':has(') || selector.includes(':nth-match(')) {
      // Use enhanced selector for complex pseudo-selectors
      const result = querySelectorAllEnhanced(selector);
      matchCount = result.elements.length;
    } else {
      matchCount = document.querySelectorAll(selector).length;
    }
  } catch (error) {
    matchCount = 0;
  }

  return {
    selector,
    method,
    isUnique: matchCount === 1,
    matchCount,
    contextStrategy,
  };
}
