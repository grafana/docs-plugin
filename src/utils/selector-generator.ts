/**
 * Smart selector generation for DOM elements
 * Creates robust, human-readable selectors while avoiding auto-generated classes
 *
 * This utility is generic and can be used in any context where you need to
 * programmatically generate CSS selectors for DOM elements.
 *
 * Key features:
 * - Walks up DOM hierarchy to find best selectable parent
 * - Prioritizes stable attributes (data-testid, id, aria-label)
 * - Filters out auto-generated classes (Emotion, CSS modules, etc.)
 * - Handles nested elements (clicks on icons/spans find parent button/link)
 * - Context-aware (includes parent selectors when needed)
 *
 * @module selector-generator
 */

import { findButtonByText } from './dom-utils';
import { querySelectorAllEnhanced } from './enhanced-selector';

/**
 * Check if an ID appears to be auto-generated
 */
function isAutoGeneratedId(id: string): boolean {
  // IDs with random hashes or UUIDs
  if (id.length > 20) {
    return true;
  }
  if (/^[a-f0-9]{8,}/.test(id)) {
    return true;
  } // Hex hashes
  if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {
    return true;
  } // UUID
  if (/^id-\d+/.test(id)) {
    return true;
  } // Auto-incremented IDs
  if (/^react-/.test(id)) {
    return true;
  } // React-generated IDs

  return false;
}

/**
 * Patterns for stable, semantic CSS classes that should be kept
 */
const STABLE_CLASS_PATTERNS = [
  /^[a-z][a-z0-9-]*(__[a-z0-9-]+)?(--[a-z0-9-]+)?$/, // BEM: block__element--modifier
  /^[a-z][a-z0-9-]+$/, // Simple kebab-case (min 2 chars to avoid 'p', 'm', etc.)
];

/**
 * Check if a class matches stable naming patterns
 */
function isStableClass(className: string): boolean {
  return STABLE_CLASS_PATTERNS.some((pattern) => pattern.test(className));
}

/**
 * Check if a class appears to be auto-generated or utility-only
 */
function isAutoGeneratedClass(className: string): boolean {
  // First check if it matches stable patterns (whitelist)
  if (isStableClass(className)) {
    return false;
  }

  // Emotion/styled-components classes
  if (className.startsWith('css-')) {
    return true;
  }

  // Classes with long hash patterns (8+ alphanumeric)
  if (/[a-zA-Z0-9]{8,}/.test(className)) {
    return true;
  }

  // Common utility classes that don't help identify elements
  const utilityClasses = [
    'flex',
    'flex-row',
    'flex-col',
    'block',
    'inline',
    'hidden',
    'absolute',
    'relative',
    'fixed',
    'static',
    'w-full',
    'h-full',
    'p-0',
    'p-1',
    'p-2',
    'p-3',
    'p-4',
    'm-0',
    'm-1',
    'm-2',
    'm-3',
    'm-4',
    'text-left',
    'text-center',
    'text-right',
    'font-bold',
    'font-normal',
    'font-light',
  ];

  if (utilityClasses.includes(className)) {
    return true;
  }

  // Grafana-specific utility patterns
  if (className.match(/^(theme|color|bg|border|rounded|shadow)-/)) {
    return true;
  }

  return false;
}

/**
 * Get unique, meaningful classes from an element
 */
function getMeaningfulClasses(element: HTMLElement): string[] {
  if (!element.className) {
    return [];
  }

  const classes = element.className.split(/\s+/).filter(Boolean);
  return classes.filter((cls) => !isAutoGeneratedClass(cls));
}

/**
 * Normalize text by removing RTL/LTR marks and collapsing whitespace
 */
function normalizeText(text: string): string {
  return text
    .replace(/[\u200e\u200f]/g, '') // Remove RTL/LTR marks
    .replace(/\s+/g, ' ') // Collapse whitespace
    .trim();
}

/**
 * Normalize href to pathname only (strip query strings and hashes)
 */
function normalizeHref(href: string): string {
  try {
    const url = new URL(href, window.location.href);
    return url.pathname; // Drop search/hash for stability
  } catch {
    return href; // Invalid URL, return as-is
  }
}

/**
 * Get test ID from any supported test ID attribute
 * Supports multiple conventions: data-testid, data-cy, data-test-id, data-qa, data-test-subj
 */
function getAnyTestId(element: HTMLElement): string | null {
  const testIdAttrs = ['data-testid', 'data-cy', 'data-test-id', 'data-qa', 'data-test-subj'];

  for (const attr of testIdAttrs) {
    if (element.hasAttribute(attr)) {
      return element.getAttribute(attr);
    }
  }

  return null;
}

/**
 * Check if button text is unique enough to use as a selector
 * Also filters out overly generic words that shouldn't be used alone
 */
function isUniqueButtonText(text: string): boolean {
  if (!text || text.length < 2) {
    return false;
  }

  // Too short or too generic - always need more context
  const genericWords = [
    'new',
    'add',
    'save',
    'cancel',
    'close',
    'ok',
    'yes',
    'no',
    'edit',
    'delete',
    'remove',
    'update',
    'submit',
    'back',
    'next',
    'confirm',
    'apply',
    'reset',
    'clear',
    'search',
    'filter',
  ];

  if (text.length < 4 || genericWords.includes(text.toLowerCase())) {
    return false; // Always need parent context for these
  }

  // Use findButtonByText to check uniqueness
  const buttons = findButtonByText(text);
  return buttons.length === 1;
}

// Note: buildCompoundSelector was replaced by buildCompoundSelectorWithContext
// which provides better specificity by including parent context

/**
 * Find the best element in the hierarchy (walk up to find semantic attributes)
 * Often users click on a span/icon inside a button/link - we want the parent
 * Prioritizes elements with strong selectable attributes
 */
function findBestElementInHierarchy(element: HTMLElement, maxDepth = 5): HTMLElement {
  let current: HTMLElement | null = element;
  let depth = 0;
  let bestElement = element;
  let bestScore = scoreElement(element);

  // First pass: look for elements with any test ID (highest priority!)
  // Also look for interactive elements (links, buttons, form controls)
  let searchElement: HTMLElement | null = element;
  let searchDepth = 0;
  while (searchElement && searchDepth < maxDepth) {
    const tag = searchElement.tagName.toLowerCase();

    // If we find any test ID attribute, that's almost always perfect!
    if (getAnyTestId(searchElement)) {
      return searchElement;
    }

    // If we find a link, button, or form control, that's also excellent
    if (tag === 'a' || tag === 'button' || tag === 'input' || tag === 'textarea' || tag === 'select') {
      return searchElement;
    }

    // If we find aria-label on an interactive element (div with role, etc.)
    if (searchElement.hasAttribute('aria-label')) {
      const role = searchElement.getAttribute('role');
      // Check if it's an interactive element (button, option, menuitem, combobox, etc.)
      if (role && ['button', 'menuitem', 'option', 'radio', 'checkbox', 'tab', 'combobox', 'listbox'].includes(role)) {
        return searchElement;
      }
      // For visualization pickers and similar, aria-label on div is often the target
      if (getAnyTestId(searchElement)) {
        return searchElement;
      }
    }

    searchElement = searchElement.parentElement;
    searchDepth++;
  }

  // Second pass: score-based search if no priority element found
  current = element;
  depth = 0;
  while (current && depth < maxDepth) {
    const score = scoreElement(current);

    if (score > bestScore) {
      bestScore = score;
      bestElement = current;
    }

    current = current.parentElement;
    depth++;
  }

  return bestElement;
}

/**
 * Score an element based on how good its attributes are for selection
 */
function scoreElement(element: HTMLElement): number {
  let score = 0;

  // Highest priority: data-testid
  if (element.hasAttribute('data-testid')) {
    score += 100;
  }

  // High priority: non-auto-generated ID
  if (element.id && !isAutoGeneratedId(element.id)) {
    score += 80;
  }

  // Good priority: aria-label
  if (element.hasAttribute('aria-label')) {
    score += 70;
  }

  // Medium priority: name attribute for inputs
  if (element.hasAttribute('name')) {
    score += 60;
  }

  // Medium priority: href for links (bump this up - links are important!)
  if (element.hasAttribute('href')) {
    score += 55;
  }

  // Very high bonus for links and buttons (they're the actual clickable elements)
  const tag = element.tagName.toLowerCase();
  if (tag === 'a') {
    score += 40;
  } // Links are very important for navigation
  if (tag === 'button') {
    score += 35;
  }

  // Bonus for other semantic tags
  const semanticTags = ['input', 'select', 'textarea'];
  if (semanticTags.includes(tag)) {
    score += 20;
  }

  // Heavy penalty for generic tags (we want to walk up past these)
  if (tag === 'SPAN') {
    score -= 20;
  }
  if (tag === 'DIV') {
    score -= 15;
  }
  if (tag === 'SVG' || tag === 'PATH') {
    score -= 25;
  } // Icons should find their parent

  return score;
}

/**
 * Generate the best CSS selector for a given DOM element
 *
 * This is the main entry point for selector generation. It automatically:
 * - Walks up the DOM tree to find the most semantically meaningful parent
 * - Prioritizes stable attributes over fragile ones
 * - Handles edge cases like clicking icons inside buttons/links
 * - Returns production-ready selectors suitable for test automation
 *
 * Priority order:
 * 1. data-testid attribute (most stable for testing)
 * 2. Non-auto-generated ID
 * 3. aria-label (semantic and accessible)
 * 4. name attribute (for form inputs)
 * 5. href attribute (for links)
 * 6. Unique button text (using findButtonByText)
 * 7. Compound selector with parent context
 * 8. Fallback to :nth-of-type
 *
 * @param element - Any HTMLElement from the DOM
 * @returns A CSS selector string that can be used with querySelector/querySelectorAll
 *
 * @example
 * ```typescript
 * // Clicking a span inside a navigation link
 * const span = document.querySelector('a[href="/dashboards"] > span');
 * const selector = generateBestSelector(span);
 * // Returns: "a[data-testid='Nav menu item'][href='/dashboards']"
 *
 * // Clicking a button with unique text
 * const button = document.querySelector('button');
 * const selector = generateBestSelector(button);
 * // Returns: "Save Dashboard" (uses button text matching)
 * ```
 */
export function generateBestSelector(element: HTMLElement): string {
  // First, walk up to find the best element in the hierarchy
  const bestElement = findBestElementInHierarchy(element);

  // 1. Check any test ID attribute (most stable)
  const testId = getAnyTestId(bestElement);
  if (testId) {
    const tag = bestElement.tagName.toLowerCase();
    // Determine which attribute was used
    const testIdAttr =
      ['data-testid', 'data-cy', 'data-test-id', 'data-qa', 'data-test-subj'].find((attr) =>
        bestElement.hasAttribute(attr)
      ) || 'data-testid';

    // For links, include normalized href for specificity
    if (tag === 'a' && bestElement.hasAttribute('href')) {
      const href = normalizeHref(bestElement.getAttribute('href')!);
      return `${tag}[${testIdAttr}="${testId}"][href="${href}"]`;
    }

    return `${tag}[${testIdAttr}="${testId}"]`;
  }

  // 2. Check ID (if not auto-generated)
  if (bestElement.id && !isAutoGeneratedId(bestElement.id)) {
    return `#${bestElement.id}`;
  }

  // 3. Check aria-label (semantic and stable)
  if (bestElement.hasAttribute('aria-label')) {
    const ariaLabel = bestElement.getAttribute('aria-label');
    const tag = bestElement.tagName.toLowerCase();
    return `${tag}[aria-label="${ariaLabel}"]`;
  }

  // 4. For inputs, check name attribute
  if (
    (bestElement.tagName === 'INPUT' || bestElement.tagName === 'TEXTAREA' || bestElement.tagName === 'SELECT') &&
    bestElement.hasAttribute('name')
  ) {
    const name = bestElement.getAttribute('name');
    const tag = bestElement.tagName.toLowerCase();
    return `${tag}[name="${name}"]`;
  }

  // 5. For links with href, use normalized pathname
  if (bestElement.tagName === 'A' && bestElement.hasAttribute('href')) {
    const href = normalizeHref(bestElement.getAttribute('href')!);
    return `a[href="${href}"]`;
  }

  // 6. For buttons, use parent context with :contains or unique text
  if (bestElement.tagName === 'BUTTON') {
    const text = bestElement.textContent;
    if (text && text.length > 0) {
      // Use normalizeText utility for consistent text handling
      const cleanText = normalizeText(text);

      if (cleanText.length > 0 && cleanText.length < 50) {
        // Strategy A: Parent context + :contains (preferred for most buttons)
        const parent = bestElement.parentElement;
        if (parent && (getAnyTestId(parent) || parent.id || parent.hasAttribute('aria-label'))) {
          const parentSelector = generateBestSelector(parent);
          return `${parentSelector} button:contains("${cleanText}")`;
        }

        // Strategy B: Standalone text ONLY if unique AND not generic
        if (isUniqueButtonText(cleanText)) {
          return cleanText; // Will use findButtonByText
        }

        // Strategy C: Standalone :contains as fallback
        return `button:contains("${cleanText}")`;
      }
    }
  }

  // 7. Build compound selector with tag + attributes + parent context
  return buildCompoundSelectorWithContext(bestElement);
}

/**
 * Build compound selector with parent context for better specificity
 * Uses parent selectors and :contains() when appropriate
 */
function buildCompoundSelectorWithContext(element: HTMLElement): string {
  const tag = element.tagName.toLowerCase();
  const parts: string[] = [tag];

  // Add meaningful classes
  const meaningfulClasses = getMeaningfulClasses(element);
  if (meaningfulClasses.length > 0) {
    parts.push(`.${meaningfulClasses[0]}`);
  }

  // Add data attributes (except auto-generated ones)
  Array.from(element.attributes).forEach((attr) => {
    if (
      attr.name.startsWith('data-') &&
      !attr.name.includes('emotion') &&
      !attr.name.includes('react') &&
      attr.value.length < 50
    ) {
      parts.push(`[${attr.name}="${attr.value}"]`);
    }
  });

  // Add normalized href for links
  if (tag === 'a' && element.hasAttribute('href')) {
    const href = normalizeHref(element.getAttribute('href')!);
    parts.push(`[href="${href}"]`);
  }

  // If we still don't have enough specificity, try these strategies:

  // Strategy 1: Use parent context if parent has good identifiers
  if (parts.length <= 2 && element.parentElement) {
    const parent = element.parentElement;

    // Check if parent has good identifying attributes
    if (getAnyTestId(parent) || parent.id || parent.hasAttribute('aria-label')) {
      const parentSelector = generateBestSelector(parent);

      // For buttons with text, use :contains for better readability
      if (tag === 'button' && element.textContent) {
        const text = normalizeText(element.textContent);
        if (text.length > 0 && text.length < 50) {
          return `${parentSelector} button:contains("${text}")`;
        }
      }

      return `${parentSelector} ${parts.join('')}`;
    }
  }

  // Strategy 2: Use :contains as fallback for elements with unique text
  if ((tag === 'button' || tag === 'a') && element.textContent) {
    const text = normalizeText(element.textContent);
    if (text.length > 0 && text.length < 50) {
      return `${tag}:contains("${text}")`;
    }
  }

  // Strategy 3: For ANY element with text content, use :contains as ultimate fallback
  if (element.textContent) {
    const text = normalizeText(element.textContent);
    // Use first few words if text is long
    const shortText = text.length > 30 ? text.substring(0, 30) + '...' : text;
    if (shortText.length > 0) {
      // If we have a parent with good ID, scope the :contains
      const parent = element.parentElement;
      if (parent && (getAnyTestId(parent) || parent.id)) {
        const parentSelector = generateBestSelector(parent);
        return `${parentSelector} ${tag}:contains("${shortText}")`;
      }
      // Otherwise use standalone :contains
      return `${tag}:contains("${shortText}")`;
    }
  }

  // Strategy 4: Add :nth-of-type with parent context as last resort
  if (element.parentElement) {
    const siblings = Array.from(element.parentElement.children).filter((el) => el.tagName === element.tagName);
    const index = siblings.indexOf(element) + 1;
    if (index > 0) {
      parts.push(`:nth-of-type(${index})`);

      // Try to add parent context for better specificity
      const parent = element.parentElement;
      if (getAnyTestId(parent) || parent.id || parent.hasAttribute('aria-label')) {
        const parentSelector = generateBestSelector(parent);
        return `${parentSelector} > ${parts.join('')}`;
      }
    }
  }

  // Absolute last resort: just return what we have
  return parts.length > 0 ? parts.join('') : `${tag}`;
}

/**
 * Get information about the generated selector for debugging
 * Returns the selector along with metadata about how it was generated
 *
 * @param element - The DOM element to analyze
 * @returns Object containing selector, generation method, uniqueness, and match count
 *
 * @example
 * ```typescript
 * const info = getSelectorInfo(myElement);
 * console.log(info.selector); // "button[data-testid='save']"
 * console.log(info.method);   // "data-testid"
 * console.log(info.isUnique); // true
 * ```
 */
export function getSelectorInfo(element: HTMLElement): {
  selector: string;
  method: string;
  isUnique: boolean;
  matchCount: number;
} {
  const selector = generateBestSelector(element);

  // Determine which method was used
  let method = 'compound';
  if (selector.includes(':contains(')) {
    method = 'contains';
  } else if (selector.includes('data-testid')) {
    method = 'data-testid';
  } else if (selector.startsWith('#')) {
    method = 'id';
  } else if (selector.includes('aria-label')) {
    method = 'aria-label';
  } else if (selector.includes('[name=')) {
    method = 'name';
  } else if (selector.includes('[href=')) {
    method = 'href';
  } else if (!selector.includes('[') && !selector.includes('.') && !selector.includes('#') && !selector.includes(':')) {
    method = 'button-text';
  } else if (selector.includes(':nth-of-type')) {
    method = 'nth-of-type';
  }

  // Check uniqueness using enhanced selector for :contains() support
  let matchCount = 0;
  try {
    if (method === 'button-text') {
      matchCount = findButtonByText(selector).length;
    } else if (method === 'contains') {
      // Use enhanced selector for :contains() support
      const result = querySelectorAllEnhanced(selector);
      matchCount = result.elements.length;
    } else {
      matchCount = document.querySelectorAll(selector).length;
    }
  } catch (error) {
    matchCount = 0;
  }

  return {
    selector,
    method,
    isUnique: matchCount === 1,
    matchCount,
  };
}
