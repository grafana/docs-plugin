/**
 * Final validation and cleaning for recorded selectors
 * Acts as a safety net to ensure all selector quality rules are applied
 */

export type ActionType =
  | 'highlight'
  | 'button'
  | 'formfill'
  | 'navigate'
  | 'hover'
  | 'sequence'
  | 'multistep'
  | 'guided';

export interface ValidatedSelector {
  selector: string;
  action: ActionType;
  warnings: string[];
  wasModified: boolean;
}

/**
 * Auto-generated CSS class patterns that should be removed or replaced
 */
const AUTO_GENERATED_CLASS_PATTERNS = [
  { pattern: /\.css-[a-z0-9-]+/gi, replacement: '', description: 'Emotion/styled-components' },
  { pattern: /\[class\*?=["'][^"']*css-[^"']+["']\]/g, replacement: '', description: 'Emotion class attribute' },
  { pattern: /\._[a-zA-Z0-9]{5,}/g, replacement: '', description: 'Webpack module hash' },
  { pattern: /\.[a-z]+-[a-z0-9]{6,}/g, replacement: '', description: 'Emotion-style hash' },
  { pattern: /\.theme-(?:dark|light)/g, replacement: '', description: 'Dynamic theme class' },
  { pattern: /input\.css-[a-z0-9-]+/gi, replacement: 'input', description: 'Input with emotion class' },
  { pattern: /button\.css-[a-z0-9-]+/gi, replacement: 'button', description: 'Button with emotion class' },
  { pattern: /div\.css-[a-z0-9-]+/gi, replacement: 'div', description: 'Div with emotion class' },
];

/**
 * Dynamic attribute patterns that should be removed
 */
const DYNAMIC_ATTRIBUTE_PATTERNS = [
  { pattern: /\[data-new-gr-c-s-check-loaded="[^"]*"\]/g, replacement: '', description: 'Grammarly extension' },
  { pattern: /\[data-gr-ext-installed="[^"]*"\]/g, replacement: '', description: 'Grammarly extension' },
  { pattern: /\[data-gr-ext-disabled="[^"]*"\]/g, replacement: '', description: 'Grammarly extension' },
  { pattern: /\[data-version="[^"]*"\]/g, replacement: '', description: 'Version attribute' },
  { pattern: /\[style="[^"]*"\]/g, replacement: '', description: 'Inline styles' },
];

/**
 * Check if a selector is plain text (no CSS syntax)
 */
function isPlainTextSelector(selector: string): boolean {
  // Plain text has no CSS syntax characters
  return (
    !selector.includes('[') &&
    !selector.includes('.') &&
    !selector.includes('#') &&
    !selector.includes(':') &&
    !selector.includes('>') &&
    !selector.includes(' ')
  );
}

/**
 * Check if a selector contains CSS syntax
 */
function hasCssSyntax(selector: string): boolean {
  return (
    selector.includes('[') ||
    selector.includes('.') ||
    selector.includes('#') ||
    selector.includes(':') ||
    selector.includes('>')
  );
}

/**
 * Remove auto-generated classes from selector
 */
function removeAutoGeneratedClasses(selector: string): { cleaned: string; removed: string[] } {
  let cleaned = selector;
  const removed: string[] = [];

  for (const { pattern, replacement, description } of AUTO_GENERATED_CLASS_PATTERNS) {
    const matches = cleaned.match(pattern);
    if (matches) {
      matches.forEach((match) => {
        if (!removed.includes(`${description}: ${match}`)) {
          removed.push(`${description}: ${match}`);
        }
      });
      cleaned = cleaned.replace(pattern, replacement);
    }
  }

  return { cleaned, removed };
}

/**
 * Remove dynamic attributes from selector
 */
function removeDynamicAttributes(selector: string): { cleaned: string; removed: string[] } {
  let cleaned = selector;
  const removed: string[] = [];

  for (const { pattern, replacement, description } of DYNAMIC_ATTRIBUTE_PATTERNS) {
    const matches = cleaned.match(pattern);
    if (matches) {
      matches.forEach((match) => {
        if (!removed.includes(`${description}: ${match}`)) {
          removed.push(`${description}: ${match}`);
        }
      });
      cleaned = cleaned.replace(pattern, replacement);
    }
  }

  return { cleaned, removed };
}

/**
 * Clean up extra whitespace and combinators
 */
function cleanWhitespace(selector: string): string {
  return selector
    .replace(/\s+/g, ' ') // Multiple spaces to single space
    .replace(/\s*>\s*/g, '>') // Clean around child combinator
    .replace(/\s*\+\s*/g, '+') // Clean around adjacent sibling
    .replace(/\s*~\s*/g, '~') // Clean around general sibling
    .trim();
}

/**
 * Validate action type matches selector type
 */
function validateActionType(
  selector: string,
  action: ActionType
): {
  correctedAction: ActionType;
  warning?: string;
} {
  const isPlainText = isPlainTextSelector(selector);
  const hasCSS = hasCssSyntax(selector);

  // Plain text selectors should use button action
  if (isPlainText && action !== 'button' && action !== 'sequence' && action !== 'multistep' && action !== 'guided') {
    return {
      correctedAction: 'button',
      warning: `Plain text selector "${selector}" should use "button" action, not "${action}"`,
    };
  }

  // CSS selectors should not use button action
  if (hasCSS && action === 'button') {
    return {
      correctedAction: 'highlight',
      warning: `CSS selector "${selector}" should use "highlight" action, not "button"`,
    };
  }

  // Radio and checkbox inputs should use highlight
  if (selector.match(/input\[type=["']?(?:radio|checkbox)["']?\]/) && action === 'formfill') {
    return {
      correctedAction: 'highlight',
      warning: `Radio/checkbox selector should use "highlight" action, not "formfill"`,
    };
  }

  return { correctedAction: action };
}

/**
 * Check if selector is too generic (likely to match multiple elements)
 */
function checkSelectorSpecificity(selector: string): string | null {
  // Body with only positional selectors is too generic
  if (selector.match(/^body(?:\[.*?\])*:nth-of-type\(\d+\)$/)) {
    return 'Body selector with only :nth-of-type is too generic';
  }

  // Generic div or span without attributes
  if (selector === 'div' || selector === 'span' || selector === 'p') {
    return 'Bare tag selector without attributes is too generic';
  }

  // Only has auto-generated attributes
  if (selector.match(/^\w+\[class\*="css-[^"]+"\]$/)) {
    return 'Selector only has auto-generated class';
  }

  return null;
}

/**
 * Final validation and cleaning of a recorded selector
 *
 * This is the safety net that ensures all quality rules are applied:
 * - Removes auto-generated CSS classes
 * - Removes dynamic attributes
 * - Validates action type matches selector type
 * - Cleans up whitespace
 * - Checks for common issues
 *
 * @param selector - The raw selector string
 * @param action - The detected action type
 * @returns Validated and cleaned selector with warnings
 */
export function validateAndCleanSelector(selector: string, action: ActionType): ValidatedSelector {
  const warnings: string[] = [];
  let cleaned = selector;
  let modified = false;

  // Step 1: Remove auto-generated classes
  const { cleaned: afterClasses, removed: removedClasses } = removeAutoGeneratedClasses(cleaned);
  if (removedClasses.length > 0) {
    cleaned = afterClasses;
    modified = true;
    warnings.push(...removedClasses.map((r) => `Removed auto-generated: ${r}`));
  }

  // Step 2: Remove dynamic attributes
  const { cleaned: afterAttrs, removed: removedAttrs } = removeDynamicAttributes(cleaned);
  if (removedAttrs.length > 0) {
    cleaned = afterAttrs;
    modified = true;
    warnings.push(...removedAttrs.map((r) => `Removed dynamic attribute: ${r}`));
  }

  // Step 3: Clean whitespace
  const afterWhitespace = cleanWhitespace(cleaned);
  if (afterWhitespace !== cleaned) {
    cleaned = afterWhitespace;
    modified = true;
  }

  // Step 4: Validate action type
  const { correctedAction, warning: actionWarning } = validateActionType(cleaned, action);
  if (actionWarning) {
    warnings.push(actionWarning);
    action = correctedAction;
    modified = true;
  }

  // Step 5: Check specificity
  const specificityWarning = checkSelectorSpecificity(cleaned);
  if (specificityWarning) {
    warnings.push(specificityWarning);
  }

  // Step 6: Final validation - ensure selector is not empty
  if (!cleaned || cleaned.trim() === '') {
    warnings.push('ERROR: Selector became empty after cleaning');
    cleaned = selector; // Revert to original
  }

  // Step 7: Verify selector actually matches elements (unless it's plain text for button action)
  const isPlainText = isPlainTextSelector(cleaned);
  if (!isPlainText) {
    try {
      // Import querySelectorAllEnhanced dynamically to avoid circular dependency
      const matches = document.querySelectorAll(cleaned);
      if (matches.length === 0) {
        warnings.push(`WARNING: Selector matches 0 elements - may need manual review`);
      }
    } catch (error) {
      // Selector might use custom pseudo-selectors - that's ok
      // The enhanced selector will handle it at runtime
    }
  }

  return {
    selector: cleaned,
    action: correctedAction,
    warnings,
    wasModified: modified,
  };
}

/**
 * Batch validate multiple selectors
 */
export function validateMultipleSelectors(
  selectors: Array<{ selector: string; action: ActionType }>
): ValidatedSelector[] {
  return selectors.map(({ selector, action }) => validateAndCleanSelector(selector, action));
}

/**
 * Get a human-readable validation report
 */
export function getValidationReport(validated: ValidatedSelector): string {
  const lines: string[] = [];

  lines.push(`Selector: ${validated.selector}`);
  lines.push(`Action: ${validated.action}`);

  if (validated.wasModified) {
    lines.push('Status: MODIFIED');
  } else {
    lines.push('Status: OK');
  }

  if (validated.warnings.length > 0) {
    lines.push('Warnings:');
    validated.warnings.forEach((w) => lines.push(`  - ${w}`));
  }

  return lines.join('\n');
}
